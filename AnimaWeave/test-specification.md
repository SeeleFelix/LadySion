# Anima Weave 测试用例指导手册

## 📋 文档目的

本文档是Anima Weave项目的**TDD指导手册**，提供：

1. **32个数学定义的测试场景** - 确保DSL语法能完整表达数学理论
2. **快速问题定位** - 出问题时能快速找到对应的测试场景
3. **TDD开发指导** - 指导测试代码的编写思路
4. **场景描述而非代码** - 专注测试逻辑，不是具体实现

---

## 📊 测试覆盖度总览

| 测试层级        | 已覆盖    | 缺失      | 覆盖率  | 状态          |
| --------------- | --------- | --------- | ------- | ------------- |
| **P1 基础语法** | 12个定义  | 4个定义   | 75%     | 🟡 基本覆盖   |
| **P2 静态检查** | 6个定义   | 2个定义   | 75%     | 🟡 大部分覆盖 |
| **P3 执行引擎** | 0个定义   | 8个定义   | 0%      | 🔴 完全缺失   |
| **总计**        | **18/32** | **14/32** | **56%** | 🟡 中等水平   |

---

## 🗂️ 按数学定义组织的测试场景

### 🎯 P0层：基础执行验证

#### T0.1: 最小可执行图验证

**测试场景 T0.1**: 基础执行引擎验证

**核心任务**: 验证最基本的DSL执行能力和包引入机制

**标准接口**: `awakening(sanctum: &str, genesis: &str) -> FateEcho`

**T0.1.1**: 基础start节点执行

- **圣所结构** (`sanctum/` - DSL源代码目录):
  ```
  sanctum/
  ├── basic.anima          # basic包定义
  └── genesis.weave     # 测试图
  ```

- **basic.anima内容**:
  ```
  -- types
  Signal
  UUID
  --

  -- nodes
  Start {
      mode Concurrent
      in {}
      out {
          signal Signal
          execution_id UUID
      }
  }
  --
  ```

- **genesis.weave内容**:
  ```
  -- import
  basic.anima
  --

  -- graph
  nodes {
      starter basic.Start
  }
  --
  ```

- **执行**: `awakening("./sanctum", "genesis")`
- **预期结果**:
  - FateEcho.status = Success
  - FateEcho.outputs包含starter节点的输出值
  - starter.signal有值（Signal类型）
  - starter.execution_id有唯一UUID值
- **验证**: 验证最基本的节点执行和输出生成

**T0.1.2**: 执行唯一性验证

- **输入DSL**: 与T0.1.1相同
- **执行**: 连续执行两次相同的图
- **预期结果**: 两次执行产生不同的execution_id
- **验证**: 验证每次执行的唯一性

**T0.1.3**: 包引入机制验证

- **输入DSL**: 不包含import的图文件
- **执行**: 尝试使用basic.Start但未import
- **预期结果**: 执行失败，报告未找到类型错误
- **验证**: 验证包引入机制的必要性

**T0.1.4**: 基础错误处理验证

- **输入DSL**: 引用不存在的节点类型
- **执行**: 尝试执行无效图
- **预期结果**: FateEcho.status = Error，包含明确错误信息
- **验证**: 验证基础错误处理机制

**关键验证点**:

- 最基本的节点执行能力
- 包引入和类型解析
- 输出值的正确生成
- 执行唯一性保证
- 基础错误处理

---

### 📐 P1层：基础语法解析 (定义1-16)

#### 定义1: 数据类型集合 𝒯

**测试场景 T1.1**: 基础数据类型解析

**T1.1.1**: 单个基础类型在types section中解析

- **输入**: 包含完整types section的.anima文件：`-- types\nint\n--`
- **预期**: 解析器识别types section并提取int类型
- **验证**: 解析结果包含types_section，其中包含DataType::Int

**T1.1.2**: 多个基础类型在types section中解析

- **输入**: 完整types section：`-- types\nint\nstring\ndouble\nbool\n--`
- **预期**: 解析器识别所有四种基础类型
- **验证**: 解析结果的types_section包含所有基础数据类型

**T1.1.3**: types section文件加载

- **输入**: 包含types section的实际.anima文件
- **预期**: 从文件系统正确加载并解析types section
- **验证**: 文件I/O和types section解析流程正确

**T1.1.4**: 无效类型名称在types section中的错误处理

- **输入**: types section中的无效类型：`-- types\ninvalid_type_name\n--`
- **预期**: 解析器报告语法错误，指向无效的type_name
- **验证**: 返回ParseError::InvalidTypeName

**T1.1.5**: 空types section处理

- **输入**: 空的types section：`-- types\n--`
- **预期**: 解析成功，types section存在但类型集合为空
- **验证**: 空types section的正确处理

**T1.1.6**: 类型名称标识符规则验证

- **输入**: `-- types\nINT\nInt\nint\n_invalid\n123invalid\n--`
- **预期**: 按标识符规则解析，字母开头，大小写敏感
- **验证**: 标识符规则的正确实施

**T1.1.7**: types section格式验证

- **输入**: 带有额外空格的types section：`--  types  \n  int  \n  string  \n--`
- **预期**: 解析器忽略WHITESPACE正确解析
- **验证**: WHITESPACE处理规则正确

**T1.1.8**: 不完整types section错误处理

- **输入**: 缺少结束标记：`-- types\nint\nstring`
- **预期**: 解析器报告section_end缺失错误
- **验证**: section语法结构验证正确

#### 定义2: 控制信号类型 𝒞

**测试场景 T1.2**: 控制信号类型的执行行为验证

**核心任务**: 验证控制信号类型(Signal)在图执行中的正确行为

**标准接口**: `awakening(sanctum: &str, genesis: &str) -> FateEcho`

**T1.2.1**: 基础控制信号传播

- **输入DSL**:
  ```
  -- types
  Signal
  --

  -- nodes
  Trigger {
      in { start Signal }
      out { signal Signal }
  }

  Logger {
      in { log Signal }
      out {}
  }
  --

  -- graph
  nodes {
      trigger Trigger
      logger Logger
  }

  controls {
      trigger.signal -> logger.log;
  }
  --
  ```
- **执行**: `awakening("./sanctum", "main")`
- **预期结果**: 触发trigger.start后，logger.log接收到控制信号
- **验证**: FateEcho显示控制信号成功传播

**T1.2.2**: 控制信号激活模式AND验证

- **输入DSL**:
  ```
  -- nodes
  AndGate {
      in { 
          signal1 Signal
          signal2 Signal
          execute Signal mode=AND
      }
      out { result Signal }
  }
  --

  -- graph
  nodes {
      source1 Trigger
      source2 Trigger
      gate AndGate
  }

  controls {
      source1.signal -> gate.signal1;
      source2.signal -> gate.signal2;
      gate.signal1 -> gate.execute;
      gate.signal2 -> gate.execute;
  }
  --
  ```
- **执行**: 只触发source1，然后同时触发source1和source2
- **预期结果**: 第一次执行gate不激活，第二次执行gate激活
- **验证**: 验证AND模式需要所有控制输入都激活

**T1.2.3**: 控制信号激活模式OR验证

- **输入DSL**: 类似T1.2.2但使用`mode=OR`
- **执行**: 只触发source1
- **预期结果**: gate立即激活
- **验证**: 验证OR模式只需要任一控制输入激活

**T1.2.4**: 控制信号激活模式XOR验证

- **输入DSL**: 类似T1.2.2但使用`mode=XOR`
- **执行**: 先触发source1，再同时触发source1和source2
- **预期结果**: 第一次gate激活，第二次gate不激活
- **验证**: 验证XOR模式需要恰好一个控制输入激活

**T1.2.5**: 控制信号与数据流的分离验证

- **输入DSL**:
  ```
  -- nodes
  Calculator {
      in { 
          a int
          b int
          execute Signal mode=AND
      }
      out { 
          result int
          done Signal
      }
  }
  --

  -- graph
  nodes {
      calc Calculator
      next Calculator
  }

  datas {
      calc.result -> next.a;
  }

  controls {
      calc.done -> next.execute;
  }
  --
  ```
- **执行**: 给calc提供数据和控制信号
- **预期结果**: 数据通过datas连接传播，控制信号通过controls连接传播
- **验证**: 验证数据流和控制流的正确分离

**T1.2.6**: 复杂控制信号网络验证

- **输入DSL**: 包含多层控制信号传播的复杂图
- **执行**: 触发入口控制信号
- **预期结果**: 控制信号按照连接关系正确传播到所有相关节点
- **验证**: 验证控制信号在复杂网络中的传播正确性

**T1.2.7**: 控制信号状态空间验证

- **输入DSL**: 包含控制信号状态转换的图
- **执行**: 观察控制信号的状态变化(+/-/⊥)
- **预期结果**: 控制信号状态按数学定义正确转换
- **验证**: 验证控制端口状态空间{+, -, ⊥}的正确实现

**T1.2.8**: 控制信号错误处理

- **输入DSL**: 包含无效控制信号连接的DSL
- **执行**: 尝试执行无效图
- **预期结果**: 引擎报告控制信号相关的错误
- **验证**: 验证控制信号类型检查和错误报告机制

**关键行为验证点**:

- 控制信号传播的正确性
- 激活模式(AND/OR/XOR)的语义正确性
- 控制流与数据流的分离
- 控制信号状态空间的正确实现
- 错误情况的正确处理

#### 定义3: 端口定义

**测试场景 T1.3**: 端口声明语法

- **输入**: `port_name type_name [modifiers]` 格式
- **预期**: 正确解析端口名、类型、修饰符
- **验证要点**: 端口三元组构建
- **测试文件**: 复杂端口定义的节点

#### 定义4: 类型兼容性关系 Γ

**测试场景 T1.4**: 类型转换关系定义

- **输入**: `int { double float }` 类型兼容性声明
- **预期**: 构建类型兼容性图
- **验证要点**: 兼容关系解析、传递性支持
- **测试文件**: 包含类型转换规则的.anima文件

#### 定义5: 节点七元组

**测试场景 T1.5**: 完整节点定义

- **输入**: 包含所有节点属性的定义：mode、in、out、config
- **预期**: 正确解析节点的七个组成部分
- **验证要点**: 节点结构完整性
- **测试文件**: 复杂节点定义

#### 定义7: 数据连接集合 𝒟

**测试场景 T1.7**: 数据连接语法

- **输入**: `datas { source.output -> target.input; }`
- **预期**: 解析数据连接集合
- **验证要点**: 连接方向、端口引用
- **测试文件**: .weave图文件

#### 定义8: 控制连接集合 ℰ

**测试场景 T1.8**: 控制连接语法

- **输入**: `controls { trigger.signal -> processor.execute; }`
- **预期**: 解析控制连接集合，与数据连接分离
- **验证要点**: 双流分离、连接类型区分
- **测试文件**: 包含controls块的.weave文件

#### 定义9: 节点集合 𝒩

**测试场景 T1.9**: 节点实例化语法

- **输入**: `nodes { instance_name NodeType }`
- **预期**: 解析节点实例声明
- **验证要点**: 实例名与类型名的绑定
- **测试文件**: 图文件中的nodes块

#### 定义10: AnimaWeave图三元组

**测试场景 T1.10**: 图结构解析

- **输入**: 完整的`-- graph --`结构
- **预期**: 解析为(𝒩, 𝒟, ℰ)三元组
- **验证要点**: 图的完整结构
- **测试文件**: 标准.weave文件

#### 定义16: 双流AnimaWeave系统

**测试场景 T1.16**: 系统级文件解析

- **输入**: 包含所有section的.anima或.weave文件
- **预期**: 解析为完整的双流系统表示
- **验证要点**: 系统完整性
- **测试文件**: 综合性的DSL文件

#### 定义19: 控制模式与激活谓词

**测试场景 T1.19**: 激活模式语法

- **输入**: `execute Signal mode=AND/OR/XOR`
- **预期**: 解析激活模式配置
- **验证要点**: 模式参数解析
- **测试文件**: 包含mode参数的端口定义

#### 定义25: 子图关系

**测试场景 T1.25**: 子图导入语法

- **输入**: `-- import subgraph.weave --`
- **预期**: 解析子图导入关系
- **验证要点**: 导入路径解析
- **测试文件**: 包含import的.weave文件

#### 定义27: 子图-节点同构

**测试场景 T1.27**: 子图实例化语法

- **输入**: `calculator add_calc.weave` 节点类型为子图
- **预期**: 解析子图作为节点类型使用
- **验证要点**: 子图类型引用
- **测试文件**: 使用子图的.weave文件

#### 定义28: 控制端口扩展

**测试场景 T1.28**: 端口扩展语法

- **输入**: 复杂的控制端口声明with多种参数
- **预期**: 解析端口扩展语法
- **验证要点**: 扩展参数解析
- **测试文件**: 复杂控制端口定义

---

### 🔍 P2层：静态检查验证 (定义11-15,26)

#### 定义11: 连接有效性约束

**测试场景 T2.11**: 端口类型匹配检查

- **输入**: 尝试连接不同类型的端口
- **预期**: 检查器发现类型不匹配并报错
- **验证要点**: 类型兼容性验证
- **失败案例**: string端口连接到int端口

#### 定义12: 图的边界端口

**测试场景 T2.12**: 边界端口自动推算

- **输入**: 包含内部连接和外部边界的图
- **预期**: 自动识别四类边界端口(数据/控制 × 输入/输出)
- **验证要点**: 边界识别算法
- **成功案例**: 复杂图的正确边界推算

#### 定义13: 必选端口DAG约束

**测试场景 T2.13**: 循环依赖检测

- **输入**: 包含循环依赖的连接图
- **预期**: 检测循环并拒绝，报告DAG约束违反
- **验证要点**: 拓扑排序算法
- **失败案例**: A→B→C→A的循环连接

#### 定义26: 子图可封装条件

**测试场景 T2.26**: 子图封装验证

- **输入**: 候选子图的封装检查
- **预期**: 验证边界端口完整性、内部连通性
- **验证要点**: 封装条件检查
- **失败案例**: 没有边界端口的孤立子图

#### 类型兼容性链验证

**测试场景 T2.4**: 传递性类型转换

- **输入**: int→double→float的连接链
- **预期**: 验证传递性类型转换的正确性
- **验证要点**: 兼容性图遍历
- **成功案例**: 多级类型转换的自动处理

#### 类型匹配验证

**测试场景 T2.1**: 基础类型匹配

- **输入**: 同类型端口的连接
- **预期**: 验证通过，允许连接
- **验证要点**: 精确类型匹配
- **成功案例**: int到int的直接连接

---

### 🚀 P3层：执行引擎语义 (定义6,14,15,17,18,20-24,29-32)

#### 定义6: 节点计算函数 φ

**测试场景 T3.6**: 节点计算逻辑

- **输入**: 节点的输入数据
- **预期**: 根据φ函数产生正确的输出
- **验证要点**: 计算函数实现
- **测试方法**: 具体节点的输入输出验证

#### 定义14: 输出端口不可变性约束

**测试场景 T3.14**: 输出不可变检查

- **输入**: 尝试修改已完成节点的输出
- **预期**: 运行时阻止修改，保持不可变性
- **验证要点**: 不可变性约束执行
- **失败案例**: 重复写入输出端口

#### 定义15: 节点执行唯一性约束

**测试场景 T3.15**: 执行唯一性检查

- **输入**: 尝试同时执行同一节点的多个实例
- **预期**: 运行时保证最多一个实例执行
- **验证要点**: 执行唯一性约束
- **失败案例**: 并发节点执行冲突

#### 定义17: 全局执行状态

**测试场景 T3.17**: 状态管理

- **输入**: 系统运行过程中的状态变化
- **预期**: 正确维护全局状态空间
- **验证要点**: 状态一致性
- **测试方法**: 状态转换的正确性验证

#### 定义18: 控制端口状态空间

**测试场景 T3.18**: 控制状态管理

- **输入**: 控制信号的传播
- **预期**: 正确管理+/-/⊥三种控制状态
- **验证要点**: 控制状态转换
- **测试方法**: 信号状态的正确维护

#### 定义20-24: 执行条件与状态转换

**测试场景 T3.20-24**: 执行语义组合

- **输入**: 复杂的节点执行场景
- **预期**: 正确的执行条件判断和状态转换
- **验证要点**: 执行语义的完整性
- **测试方法**: 端到端的执行流程验证

#### 定义29-32: 信号传播机制

**测试场景 T3.29-32**: 信号传播引擎

- **输入**: 控制信号在图中的传播
- **预期**: 正确的信号传播和端口值计算
- **验证要点**: 信号传播算法
- **测试方法**: 信号流的端到端验证

---

## 🎯 TDD开发指导

### 开发顺序建议

1. **P1层优先** - 确保DSL语法完整可解析
2. **P2层核心** - 实现Anima Weave的智能检查特性
3. **P3层完善** - 最后实现运行时执行语义

### 测试编写原则

1. **场景驱动** - 每个测试基于明确的使用场景
2. **定义对应** - 每个测试验证特定的数学定义
3. **快速定位** - 测试失败时能快速定位到对应的数学概念
4. **渐进验证** - 从简单到复杂逐步验证功能

### 问题调试流程

1. **定位定义** - 确定问题涉及哪个数学定义
2. **找到场景** - 查找对应的测试场景
3. **验证实现** - 检查实现是否符合场景预期
4. **修正代码** - 基于场景描述修正实现

---

_这是一个活文档，会随着TDD进展不断完善。重点是指导思路，不是具体代码。_ 🎯
