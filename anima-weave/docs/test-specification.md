# Anima Weave 测试用例指导手册

## 📋 文档目的

本文档是Anima Weave项目的**TDD指导手册**，提供：

1. **32个数学定义的测试场景** - 确保DSL语法能完整表达数学理论
2. **快速问题定位** - 出问题时能快速找到对应的测试场景
3. **TDD开发指导** - 指导测试代码的编写思路
4. **场景描述而非代码** - 专注测试逻辑，不是具体实现

---

## 📊 测试覆盖度总览

| 测试层级        | 已覆盖    | 缺失      | 覆盖率  | 状态          |
| --------------- | --------- | --------- | ------- | ------------- |
| **P1 基础语法** | 12个定义  | 4个定义   | 75%     | 🟡 基本覆盖   |
| **P2 静态检查** | 6个定义   | 2个定义   | 75%     | 🟡 大部分覆盖 |
| **P3 执行引擎** | 0个定义   | 8个定义   | 0%      | 🔴 完全缺失   |
| **总计**        | **18/32** | **14/32** | **56%** | 🟡 中等水平   |

---

## 🗂️ 按数学定义组织的测试场景

### 📐 P1层：基础语法解析 (定义1-16)

#### 定义1: 语义标签集合 ℒ

**测试场景 T1.1**: 语义标签在图执行中的传播验证

**核心任务**: 验证语义标签集合ℒ在图执行过程中的正确识别、传播和序列化

**标准接口**: `awakening(sanctum: &str, weave_filename: &str) -> FateEcho`

**T1.1.1**: 基础语义标签执行传播

- **图设计**: 包含基础语义标签类型的完整计算链
  ```
  Start → GetTimestamp → IsEven → FormatNumber
  Signal   UUID→Int     Int→Bool  Bool→String
  ```
- **预期行为**: 每个节点产生正确的语义标签输出
- **验证要点**: 
  - FateEcho.outputs包含所有终端节点输出
  - 每个输出值携带正确的语义标签：`basic.UUID`, `basic.Int`, `basic.Bool`, `basic.String`
  - JSON序列化保持语义标签结构：`{semantic_label: "basic.Type", value: actualValue}`

**T1.1.2**: 组合语义标签构造验证

- **图设计**: 构造复杂组合语义标签的计算流程
  ```
  Start → GetTimestamp → CreatePrompt
  Signal   UUID         Prompt{id,name,content}
  ```
- **预期行为**: 组合类型的正确构造和嵌套语义标签传播
- **验证要点**:
  - Prompt对象的顶层语义标签：`basic.Prompt`
  - 嵌套字段的语义标签保持：`id: basic.String`, `name: basic.String`, `content: basic.String`
  - 组合类型的完整JSON序列化结构

**T1.1.3**: 语义标签类型转换验证

- **图设计**: 涉及类型兼容性转换的计算链
  ```
  NumberGenerator → TypeConverter → StringFormatter
  Int              Int→Double      Double→String
  ```
- **预期行为**: 兼容类型间的安全转换和语义标签更新
- **验证要点**:
  - 转换过程中语义标签的正确更新
  - 转换后值的类型正确性
  - 兼容性链的传递性验证

**T1.1.4**: 语义标签验证失败场景

- **图设计**: 故意包含不兼容语义标签连接的图
  ```
  PromptCreator → NumberProcessor
  Prompt        Int (不兼容)
  ```
- **预期行为**: 静态验证阶段拒绝不兼容连接
- **验证要点**:
  - FateEcho.status为ValidationError
  - 错误信息明确指出语义标签不匹配
  - 错误定位到具体的连接位置

**T1.1.5**: 语义标签集合完整性验证

- **图设计**: 包含basic插件所有支持语义标签的综合图
- **预期行为**: 所有语义标签类型在图执行中的正确体现
- **验证要点**:
  - 基础类型：Int, Bool, String, UUID, Signal
  - 语义类型：Prompt, Rules, UserInput
  - 每种类型的序列化格式一致性

**T1.1.6**: 语义标签状态边界验证

- **图设计**: 测试语义标签的边界值和特殊状态
- **预期行为**: 边界情况下语义标签的健壮性
- **验证要点**:
  - 空值的语义标签处理
  - 默认值的语义标签分配
  - 异常情况下的语义标签保持

**T1.1.7**: 语义标签序列化一致性验证

- **图设计**: 同一图的多次执行结果比较
- **预期行为**: 语义标签序列化格式的一致性
- **验证要点**:
  - 多次执行的语义标签格式稳定
  - JSON序列化的标准化结构
  - 语义标签字符串的规范性

**T1.1.8**: 语义标签扩展性验证

- **图设计**: 测试语义标签系统对新类型的支持能力
- **预期行为**: 语义标签系统的可扩展性
- **验证要点**:
  - 新语义标签的动态注册
  - 扩展类型的序列化支持
  - 向后兼容性的保持

#### 定义2: 控制信号类型 𝒞

**测试场景 T1.2**: 控制信号类型的执行行为验证

**核心任务**: 验证控制信号类型(Signal)在图执行中的正确行为

**标准接口**: `awakening(sanctum: &str, genesis: &str) -> FateEcho`

**T1.2.1**: 基础控制信号传播

- **输入DSL**:
  ```
  -- types
  Signal
  --

  -- nodes
  Trigger {
      in { start Signal }
      out { signal Signal }
  }

  Logger {
      in { log Signal }
      out {}
  }
  --

  -- graph
  nodes {
      trigger Trigger
      logger Logger
  }

  controls {
      trigger.signal -> logger.log;
  }
  --
  ```
- **执行**: `awakening("./sanctum", "main")`
- **预期结果**: 触发trigger.start后，logger.log接收到控制信号
- **验证**: FateEcho显示控制信号成功传播

**T1.2.2**: 控制信号激活模式AND验证

- **输入DSL**:
  ```
  -- nodes
  AndGate {
      in { 
          signal1 Signal
          signal2 Signal
          execute Signal mode=AND
      }
      out { result Signal }
  }
  --

  -- graph
  nodes {
      source1 Trigger
      source2 Trigger
      gate AndGate
  }

  controls {
      source1.signal -> gate.signal1;
      source2.signal -> gate.signal2;
      gate.signal1 -> gate.execute;
      gate.signal2 -> gate.execute;
  }
  --
  ```
- **执行**: 只触发source1，然后同时触发source1和source2
- **预期结果**: 第一次执行gate不激活，第二次执行gate激活
- **验证**: 验证AND模式需要所有控制输入都激活

**T1.2.3**: 控制信号激活模式OR验证

- **输入DSL**: 类似T1.2.2但使用`mode=OR`
- **执行**: 只触发source1
- **预期结果**: gate立即激活
- **验证**: 验证OR模式只需要任一控制输入激活

**T1.2.4**: 控制信号激活模式XOR验证

- **输入DSL**: 类似T1.2.2但使用`mode=XOR`
- **执行**: 先触发source1，再同时触发source1和source2
- **预期结果**: 第一次gate激活，第二次gate不激活
- **验证**: 验证XOR模式需要恰好一个控制输入激活

**T1.2.5**: 控制信号与数据流的分离验证

- **输入DSL**:
  ```
  -- nodes
  Calculator {
      in { 
          a int
          b int
          execute Signal mode=AND
      }
      out { 
          result int
          done Signal
      }
  }
  --

  -- graph
  nodes {
      calc Calculator
      next Calculator
  }

  datas {
      calc.result -> next.a;
  }

  controls {
      calc.done -> next.execute;
  }
  --
  ```
- **执行**: 给calc提供数据和控制信号
- **预期结果**: 数据通过datas连接传播，控制信号通过controls连接传播
- **验证**: 验证数据流和控制流的正确分离

**T1.2.6**: 复杂控制信号网络验证

- **输入DSL**: 包含多层控制信号传播的复杂图
- **执行**: 触发入口控制信号
- **预期结果**: 控制信号按照连接关系正确传播到所有相关节点
- **验证**: 验证控制信号在复杂网络中的传播正确性

**T1.2.7**: 控制信号状态空间验证

- **输入DSL**: 包含控制信号状态转换的图
- **执行**: 观察控制信号的状态变化(+/-/⊥)
- **预期结果**: 控制信号状态按数学定义正确转换
- **验证**: 验证控制端口状态空间{+, -, ⊥}的正确实现

**T1.2.8**: 控制信号错误处理

- **输入DSL**: 包含无效控制信号连接的DSL
- **执行**: 尝试执行无效图
- **预期结果**: 引擎报告控制信号相关的错误
- **验证**: 验证控制信号类型检查和错误报告机制

**关键行为验证点**:

- 控制信号传播的正确性
- 激活模式(AND/OR/XOR)的语义正确性
- 控制流与数据流的分离
- 控制信号状态空间的正确实现
- 错误情况的正确处理

#### 定义3: 端口定义

**测试场景 T1.3**: 端口声明语法

- **输入**: `port_name type_name [modifiers]` 格式
- **预期**: 正确解析端口名、类型、修饰符
- **验证要点**: 端口三元组构建
- **测试文件**: 复杂端口定义的节点

#### 定义4: 类型兼容性关系 Γ

**测试场景 T1.4**: 类型转换关系定义

- **输入**: `int { double float }` 类型兼容性声明
- **预期**: 构建类型兼容性图
- **验证要点**: 兼容关系解析、传递性支持
- **测试文件**: 包含类型转换规则的.anima文件

#### 定义5: 节点七元组

**测试场景 T1.5**: 完整节点定义

- **输入**: 包含所有节点属性的定义：mode、in、out、config
- **预期**: 正确解析节点的七个组成部分
- **验证要点**: 节点结构完整性
- **测试文件**: 复杂节点定义

#### 定义7: 数据连接集合 𝒟

**测试场景 T1.7**: 数据连接语法

- **输入**: `datas { source.output -> target.input; }`
- **预期**: 解析数据连接集合
- **验证要点**: 连接方向、端口引用
- **测试文件**: .weave图文件

#### 定义8: 控制连接集合 ℰ

**测试场景 T1.8**: 控制连接语法

- **输入**: `controls { trigger.signal -> processor.execute; }`
- **预期**: 解析控制连接集合，与数据连接分离
- **验证要点**: 双流分离、连接类型区分
- **测试文件**: 包含controls块的.weave文件

#### 定义9: 节点集合 𝒩

**测试场景 T1.9**: 节点实例化语法

- **输入**: `nodes { instance_name NodeType }`
- **预期**: 解析节点实例声明
- **验证要点**: 实例名与类型名的绑定
- **测试文件**: 图文件中的nodes块

#### 定义10: AnimaWeave图三元组

**测试场景 T1.10**: 图结构解析

- **输入**: 完整的`-- graph --`结构
- **预期**: 解析为(𝒩, 𝒟, ℰ)三元组
- **验证要点**: 图的完整结构
- **测试文件**: 标准.weave文件

#### 定义16: 双流AnimaWeave系统

**测试场景 T1.16**: 系统级文件解析

- **输入**: 包含所有section的.anima或.weave文件
- **预期**: 解析为完整的双流系统表示
- **验证要点**: 系统完整性
- **测试文件**: 综合性的DSL文件

#### 定义19: 控制模式与激活谓词

**测试场景 T1.19**: 激活模式语法

- **输入**: `execute Signal mode=AND/OR/XOR`
- **预期**: 解析激活模式配置
- **验证要点**: 模式参数解析
- **测试文件**: 包含mode参数的端口定义

#### 定义25: 子图关系

**测试场景 T1.25**: 子图导入语法

- **输入**: `-- import subgraph.weave --`
- **预期**: 解析子图导入关系
- **验证要点**: 导入路径解析
- **测试文件**: 包含import的.weave文件

#### 定义27: 子图-节点同构

**测试场景 T1.27**: 子图实例化语法

- **输入**: `calculator add_calc.weave` 节点类型为子图
- **预期**: 解析子图作为节点类型使用
- **验证要点**: 子图类型引用
- **测试文件**: 使用子图的.weave文件

#### 定义28: 控制端口扩展

**测试场景 T1.28**: 端口扩展语法

- **输入**: 复杂的控制端口声明with多种参数
- **预期**: 解析端口扩展语法
- **验证要点**: 扩展参数解析
- **测试文件**: 复杂控制端口定义

---

### 🔍 P2层：静态检查验证 (定义11-15,26)

#### 定义11: 连接有效性约束

**测试场景 T2.11**: 端口类型匹配检查

- **输入**: 尝试连接不同类型的端口
- **预期**: 检查器发现类型不匹配并报错
- **验证要点**: 类型兼容性验证
- **失败案例**: string端口连接到int端口

#### 定义12: 图的边界端口

**测试场景 T2.12**: 边界端口自动推算

- **输入**: 包含内部连接和外部边界的图
- **预期**: 自动识别四类边界端口(数据/控制 × 输入/输出)
- **验证要点**: 边界识别算法
- **成功案例**: 复杂图的正确边界推算

#### 定义13: 必选端口DAG约束

**测试场景 T2.13**: 循环依赖检测

- **输入**: 包含循环依赖的连接图
- **预期**: 检测循环并拒绝，报告DAG约束违反
- **验证要点**: 拓扑排序算法
- **失败案例**: A→B→C→A的循环连接

#### 定义26: 子图可封装条件

**测试场景 T2.26**: 子图封装验证

- **输入**: 候选子图的封装检查
- **预期**: 验证边界端口完整性、内部连通性
- **验证要点**: 封装条件检查
- **失败案例**: 没有边界端口的孤立子图

#### 类型兼容性链验证

**测试场景 T2.4**: 传递性类型转换

- **输入**: int→double→float的连接链
- **预期**: 验证传递性类型转换的正确性
- **验证要点**: 兼容性图遍历
- **成功案例**: 多级类型转换的自动处理

#### 类型匹配验证

**测试场景 T2.1**: 基础类型匹配

- **输入**: 同类型端口的连接
- **预期**: 验证通过，允许连接
- **验证要点**: 精确类型匹配
- **成功案例**: int到int的直接连接

---

### 🚀 P3层：执行引擎语义 (定义6,14,15,17,18,20-24,29-32)

#### 定义6: 节点计算函数 φ

**测试场景 T3.6**: 节点计算逻辑

- **输入**: 节点的输入数据
- **预期**: 根据φ函数产生正确的输出
- **验证要点**: 计算函数实现
- **测试方法**: 具体节点的输入输出验证

#### 定义14: 输出端口不可变性约束

**测试场景 T3.14**: 输出不可变检查

- **输入**: 尝试修改已完成节点的输出
- **预期**: 运行时阻止修改，保持不可变性
- **验证要点**: 不可变性约束执行
- **失败案例**: 重复写入输出端口

#### 定义15: 节点执行唯一性约束

**测试场景 T3.15**: 执行唯一性检查

- **输入**: 尝试同时执行同一节点的多个实例
- **预期**: 运行时保证最多一个实例执行
- **验证要点**: 执行唯一性约束
- **失败案例**: 并发节点执行冲突

#### 定义17: 全局执行状态

**测试场景 T3.17**: 状态管理

- **输入**: 系统运行过程中的状态变化
- **预期**: 正确维护全局状态空间
- **验证要点**: 状态一致性
- **测试方法**: 状态转换的正确性验证

#### 定义18: 控制端口状态空间

**测试场景 T3.18**: 控制状态管理

- **输入**: 控制信号的传播
- **预期**: 正确管理+/-/⊥三种控制状态
- **验证要点**: 控制状态转换
- **测试方法**: 信号状态的正确维护

#### 定义20-24: 执行条件与状态转换

**测试场景 T3.20-24**: 执行语义组合

- **输入**: 复杂的节点执行场景
- **预期**: 正确的执行条件判断和状态转换
- **验证要点**: 执行语义的完整性
- **测试方法**: 端到端的执行流程验证

#### 定义29-32: 信号传播机制

**测试场景 T3.29-32**: 信号传播引擎

- **输入**: 控制信号在图中的传播
- **预期**: 正确的信号传播和端口值计算
- **验证要点**: 信号传播算法
- **测试方法**: 信号流的端到端验证

---

## 🎯 TDD开发指导

### 开发顺序建议

1. **P1层优先** - 确保DSL语法完整可解析
2. **P2层核心** - 实现Anima Weave的智能检查特性
3. **P3层完善** - 最后实现运行时执行语义

### 测试编写原则

1. **场景驱动** - 每个测试基于明确的使用场景
2. **定义对应** - 每个测试验证特定的数学定义
3. **快速定位** - 测试失败时能快速定位到对应的数学概念
4. **渐进验证** - 从简单到复杂逐步验证功能

### 问题调试流程

1. **定位定义** - 确定问题涉及哪个数学定义
2. **找到场景** - 查找对应的测试场景
3. **验证实现** - 检查实现是否符合场景预期
4. **修正代码** - 基于场景描述修正实现

---

_这是一个活文档，会随着TDD进展不断完善。重点是指导思路，不是具体代码。_ 🎯
